=========================
Sensitive Data Encryption
=========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Introduction
------------

Many applications make use of sensitive data such as confidential personal details, payment information, or proprietary data. In some jurisdictions, this type of data is subject to governance, privacy, and security compliance mandates. Unauthorized access of sensitive data or a failure to comply with a mandate often results in significant reputation damage and financial penalties. Therefore, it is important to keep sensitive data secure.

MongoDB offers several methods that protect your data from unauthorized access including:

* `Role-based access control <https://docs.mongodb.com/manual/core/authorization/>`_
* `Monitoring and logging <https://docs.mongodb.com/manual/core/auditing/>`_
* `TLS/SSL network transport encryption <https://docs.mongodb.com/manual/core/security-transport-encryption/>`_
* `Encryption at rest <https://docs.mongodb.com/manual/core/security-encryption-at-rest/>`_

Another MongoDB feature that prevents unauthorized access of data is `Client-Side Field Level Encryption (CSFLE) <https://docs.mongodb.com/manual/core/security-client-side-encryption/>`_. This feature allows a developer to selectively encrypt individual fields of a document on the client-side before it is sent to the server. This keeps the encrypted data private from the providers hosting the database as well as any user that has direct access to the database.

This guide provides steps for setup and implementation of CSFLE with a practical example.

.. note::

  Client-side Field Level Encryption is available starting in MongoDB 4.2 Enterprise only.

Problem
~~~~~~~

In this scenario, we secure sensitive data on a Medical Care Management System which stores patients' personal information, insurance information, and medical records for a fictional company, *MedcoMD*. None of the patient data is public, and certain data such as their social security number (SSN), insurance policy number, and vital sign measurements are particularly sensitive and subject to privacy compliance. It is important for the company and the patient that the data is kept private and secure.

MedcoMD needs this system to satisfy the following use cases:

- Doctors use the system to access Patients' medical records, insurance information, and add new vital sign measurements.
- Receptionists use the system to verify the Patients' identity, using a combination of their contact information and the last four digits of their Social Security Number (SSN).
- Receptionists can view a Patient's insurance policy provider, but not their policy number.
- Receptionists cannot access a Patient's medical records.

MedcoMD is also concerned with disclosure of sensitive data through any of the following methods:

- Accidental disclosure of data on the Receptionist's publicly-viewable screen.
- Direct access to the database by a superuser such as a database administrator.
- Capture of data over an insecure network.
- Access to the data by reading a server's memory.
- Access to the on-disk data by reading database or backup files.

What can MedcoMD do to balance the functionality and access restrictions of their Medical Care Management System?

Solution
~~~~~~~~

The MedcoMD software engineers review the Medical Care Management System specification and research the proper solution for limiting access to sensitive data.

The first MongoDB security feature they evaluated was `Role-Based Access Control <https://docs.mongodb.com/manual/core/authorization/>`_ which allows administrators to grant and restrict collection-level permissions for users. With the appropriate role definition and assignment, this solution prevents accidental disclosure of data and access. However, it does not prevent capture of the data over an insecure network, direct access of data by a superuser, access to data by reading the server's memory, or access to on-disk data by reading the database or backup files.

The next MongoDB security features they evaluated were `Encryption at Rest <https://docs.mongodb.com/manual/core/security-encryption-at-rest/>`_ which encrypts the database files on disk and `Transport Encryption using TLS/SSL <https://docs.mongodb.com/manual/core/security-transport-encryption/>`_ which encrypts data over the network. When applied together, these two features prevent access to on-disk database files as well as capture of the data on the network, respectively. When combined with Role-Based Access Control, these three security features offer near-comprehensive security coverage of the sensitive data, but lack a mechanism to prevent the data from being read from the server's memory.

Finally, the MedcoMD developers discovered a feature that independently satisfies all the security criteria. Client-side Field Level Encryption allows the developers to specify the fields of a document that should be kept encrypted. Sensitive data is transparently encrypted/decrypted by the client and only communicated to and from the server in encrypted form. This mechanism keeps the specified data fields secure in encrypted form on both the server and the network. While all clients have access to the non-sensitive data fields, only appropriately-configured CSFLE clients are able to read and write the sensitive data fields.

MedcoMD will provide Receptionists with a client that is not configured to access data encrypted with CSFLE. This will prevent them from viewing the sensitive fields and accidentally leaving them displayed on-screen in a public area. MedcoMD will provide Doctors with a client with CSFLE enabled which will allow them to access the sensitive data fields in the privacy of their own office.

Equipped with CSFLE, MedcoMD can keep their sensitive data secure and compliant to data privacy regulations with MongoDB.

Procedure
---------

Requirements
~~~~~~~~~~~~

- Point to setup and install directions
- Nullam imperdiet lorem vitae vulputate lacinia.
- Donec eget velit tincidunt, gravida diam ac, efficitur lacus.

A. Create a Master Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MongoDB `Client-Side Field Level Encryption (CSFLE) <https://docs.mongodb.com/manual/core/security-client-side-encryption/>`_ uses an encryption strategy called *envelope encryption* in which keys used to encrypt/decrypt data (called **data encryption keys**) are encrypted with another key (called the **master key**). For more information on the features of envelope encryption and key management concepts, see `AWS Key Management Service Concepts <https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#enveloping>`_.

The master key, used by the MongoDB driver to create and encrypt data keys, should be stored remotely in a `Key Management System <https://en.wikipedia.org/wiki/Key_management#Key_management_system>`_. The data encryption keys, generated and used by the MongoDB driver to encrypt and decrypt document fields, are stored in a key vault collection in the same database as the encrypted data.

In this step, we generate a local master key to expedite setup of our development environment.

.. admonition:: Local Master Keys Are Not Secure
   :class: important

   To ensure that the master key cannot be compromised, do not use a local master key in a production environment. Instead, use a secure KMS such as `AWS KMS <https://aws.amazon.com/kms/>`_.

   We demonstrate how to transition from a locally-hosted master key to a remote AWS KMS master key in a later step of this guide.

.. tabs::

  tabs:

    - id: java-master-key-generator
      name: "Java"
      content: |

        The following script generates a 96-byte local master key and saves it to a file called ``master-key.txt`` in the directory from which the script is executed.

        .. code-block:: java

          import java.io.FileOutputStream;
          import java.io.IOException;
          import java.security.SecureRandom;

          public class CreateMasterKeyFile {
            public static void main(final String[] args) {

              final byte[] localMasterKey = new byte[96];
              new SecureRandom().nextBytes(localMasterKey);

              try (FileOutputStream stream = new FileOutputStream("master-key.txt")) {
                stream.write(localMasterKey);
              } catch (IOException e)  {
                e.printStackTrace();
              }
            }
          }


B. Create a Data Encryption Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this section, we use the MongoDB driver to create and store a data
encryption key, used by CSFLE to automatically encrypt and decrypt data on
document fields. The following configuration values are required by the client
to generate a new data encryption key:

* The local master key or AWS KMS master key access settings.
* A MongoDB connection string that authenticates on a running server.
* The key vault database and collection name.

Upon creating a data encryption key, the driver returns the ``_id`` field
(as a `UUID <https://en.wikipedia.org/wiki/Universally_unique_identifier>`_)
of a document that stores information about the key including:

* The data encryption key, encrypted by the master key.
* The key management service provider data.

Follow the steps below to generate a single data encryption key from the
local master key.

.. note::

  If using AWS KMS to provide the master key, refer to the "`F. Convert to
  a Remote Master Key`_" section for the appropriate settings.

First, read the file containing the local master key generated in the "`A.
Create a Master Key`_" section:

.. tabs::

  tabs:

    - id: java-master-key-reader
      name: "Java"
      content: |

        .. code-block:: java

          String path = "master-key.txt";

          byte[] fileBytes = new byte[96];

          try (FileInputStream fis = new FileInputStream(path)) {
            fileBytes = fis.readAllBytes();
          } catch (IOException e) {
            e.printStackTrace();
          }

          final byte[] localMasterKey = Arrays.copyOf(fileBytes, 96);


Next, specify the KMS provider settings. Since we are using a local master
key, the provider name is ``local``:

.. tabs::

  tabs:

    - id: java-kms-settings-local
      name: "Java"
      content: |

        .. code-block:: java

          String kmsProvider = "local";

          Map<String, Map<String, Object>> kmsProviders = new HashMap<String, Map<String, Object>>() {{
             put(kmsProvider, new HashMap<String, Object>() {{
                 put("key", localMasterKey);
             }});
          }};


Create the client with the MongoDB connection string and key vault namespace
(database and collection name):

.. tabs::

  tabs:

    - id: java-keyvault-settings-local
      name: "Java"
      content: |

        .. code-block:: java

          String connectionString = "mongodb://localhost:27017";
          String keyVaultNamespace = "encryption.__keyVault";

          ClientEncryptionSettings clientEncryptionSettings = ClientEncryptionSettings.builder()
                  .keyVaultMongoClientSettings(MongoClientSettings.builder()
                          .applyConnectionString(new ConnectionString(connectionString))
                          .build())
                  .keyVaultNamespace(keyVaultNamespace)
                  .kmsProviders(kmsProviders)
                  .build();

          ClientEncryption clientEncryption = ClientEncryptions.create(clientEncryptionSettings);


.. note::

  Ensure that the client has `ReadWrite
  <https://docs.mongodb.com/manual/reference/built-in-roles/#readWrite>`_
  permissions to the specified key vault
  namespace.

Use the client to generate a data encryption key and convert the returned key
id to base64 for usage in the following "`C. Define a JSON Schema`_" section.

.. tabs::

  tabs:

    - id: java-kms-settings-local
      name: "Java"
      content: |

        .. code-block:: java

          BsonBinary dataKeyId = clientEncryption.createDataKey("local", new DataKeyOptions());
          final String base64DataKeyId = Base64.getEncoder().encodeToString(dataKeyId.getData());


Verify that the key was created in your MongoDB replica set in the specified
key vault namespace. The document should resemble the following:

.. code-block:: javascript

  {
    "_id" : UUID("..."),
    "keyMaterial" : BinData(0,"..."),
    "creationDate" : ISODate("..."),
    "updateDate" : ISODate("..."),
    "status" : 0,
    "masterKey" : {
      "provider" : "local"
    }
  }

`Click here <https://raw.githubusercontent.com/mongodb/docs-assets/DOCSP-csfle-data-encryption-key/DataEncryptionKeyGenerator.java>`_
for the source code used to generate the data encryption key in this section.


C. Define a JSON Schema
~~~~~~~~~~~~~~~~~~~~~~~

.. _DeterministicVsRandom:

Deterministic vs Random Encryption
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Proin non mi a felis luctus vulputate nec pharetra odio. Ut pretium
scelerisque nulla, sed euismod nisi pellentesque sit amet. Proin mollis
mauris eu libero ullamcorper rutrum. Pellentesque vitae enim sed magna
accumsan maximus et quis mi. Ut vel laoreet turpis. Vivamus vitae odio
sed arcu finibus pretium vel maximus nisi. Nullam gravida consequat
porta.

C. Configure the MongoDB Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Donec sem felis, iaculis id pharetra sed, sollicitudin ut nisl.
Suspendisse commodo sagittis ante in ullamcorper. Etiam viverra
pellentesque suscipit. Pellentesque interdum egestas libero, ut varius
velit congue vel.

E. Perform Encrypted Read/Write Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Etiam hendrerit posuere justo, ac hendrerit lorem pellentesque sed.
Fusce ullamcorper neque eu libero aliquam, sed placerat sapien cursus.
Vestibulum maximus magna sed velit feugiat tempor.

Ut accumsan pellentesque metus, at porta felis dapibus vulputate. Aenean
malesuada interdum libero in feugiat. Fusce pharetra massa eget leo
varius, et gravida massa tempus.

Ut mattis eros elit, sed ultrices purus lacinia sed. Curabitur tincidunt
tellus eget neque porta dictum ac vel orci. Vestibulum ante ipsum primis
in faucibus orci luctus et ultrices posuere cubilia Curae.

Praesent feugiat arcu non risus elementum eleifend. Nullam sed iaculis
erat.

F. Convert to a Remote Master Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fusce porta lectus et enim vehicula malesuada. In porttitor ipsum eu
dictum congue. Fusce pharetra sagittis lacus sed posuere. Donec porta
posuere gravida. Quisque nisi massa, condimentum vitae ligula eget,
fringilla malesuada quam. Mauris in semper nulla, non blandit tortor.
Mauris consequat eget urna at eleifend. Suspendisse potenti. Fusce at
justo malesuada, finibus felis non, dignissim nisl. Ut blandit nulla sit
amet massa euismod vehicula.

Summary
-------

- What we wanted to do
- What we did
- More reading
